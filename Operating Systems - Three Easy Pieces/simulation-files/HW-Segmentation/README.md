# `segmentation.py`

This program allows you to see how address translations are performed in a system with segmentation. The segmentation that this system uses is pretty simple: an address space has just _two_ segments; further, the top bit of the virtual address generated by the process determines which segment the address is in: 0 for segment 0 (where, say, code and the heap would reside) and 1 for segment 1 (where the stack lives). Segment 0 grows in a positive direction (towards higher addresses), whereas segment 1 grows in the negative direction.

There are two steps to running the program to test out your understanding of segmentation.

First, run without the `-c` flag: this shows you what problem to solve without revealing the answers. For example, to run with the default flags, type:

```bash
python3 ./segmentation.py
```


This is what you should see:

```bash
ARG seed 0
ARG address space size 1k
ARG phys mem size 16k

Segment register information:

  Segment 0 base  (grows positive) : 0x00001aea (decimal 6890)
  Segment 0 limit                  : 472

  Segment 1 base  (grows negative) : 0x00001254 (decimal 4692)
  Segment 1 limit                  : 450

Virtual Address Trace
  VA  0: 0x0000020b (decimal:  523) --> PA or segmentation violation?
  VA  1: 0x0000019e (decimal:  414) --> PA or segmentation violation?
  VA  2: 0x00000322 (decimal:  802) --> PA or segmentation violation?
  VA  3: 0x00000136 (decimal:  310) --> PA or segmentation violation?
  VA  4: 0x000001e8 (decimal:  488) --> PA or segmentation violation?

For each virtual address, either write down the physical address it translates
to OR write down that it is an out-of-bounds address (a segmentation
violation). For this problem, you should assume a simple address space with
two segments: the top bit of the virtual address can thus be used to check
whether the virtual address is in segment 0 (topbit=0) or segment 1
(topbit=1). Note that the baspython3 ./limit pairs given to you grow in different
directions, depending on the segment, i.e., segment 0 grows in the positive
direction, whereas segment 1 in the negative.
```

As you can see from this example, a set of virtual addresses are generated. As the program states, you can now use this to compute the translations and see if you have a grip on the basic concepts.

Once you are done, you can use the same program to "solve" the problem and see if you did your work correctly. To do so, use the `-c` flag. The output:

```bash
promtp> python3 ./segmentation.py -c

ARG seed 0
ARG address space size 1k
ARG phys mem size 16k

Segment register information:

  Segment 0 base  (grows positive) : 0x00001aea (decimal 6890)
  Segment 0 limit                  : 472

  Segment 1 base  (grows negative) : 0x00001254 (decimal 4692)
  Segment 1 limit                  : 450

Virtual Address Trace
  VA  0: 0x0000020b (decimal:  523) --> SEGMENTATION VIOLATION (SEG1)
  VA  1: 0x0000019e (decimal:  414) --> VALID in SEG0: 0x00001c88 (decimal: 7304)
  VA  2: 0x00000322 (decimal:  802) --> VALID in SEG1: 0x00001176 (decimal: 4470)
  VA  3: 0x00000136 (decimal:  310) --> VALID in SEG0: 0x00001c20 (decimal: 7200)
  VA  4: 0x000001e8 (decimal:  488) --> SEGMENTATION VIOLATION (SEG0)
```

As you can see from the figure, the `-c` flag shows you what happened. The program translates the addresses for you, and hence you can check if you understand how a system using segmentation translates addresses.

If you want to try the same type of problem but with different inputs, try changing the random seed, the address space size, or the physical memory size. Different random seeds basically give you a way to generate an infinite number of different problems for yourself, and the `-c` flag lets you check your own work. Keep doing this until you feel like you really understand the concepts.

One other useful flag is `-s` (seed), which lets you generate different problems by passing in a different random seed. Of course, make sure to use the same random seed when you are generating a problem and then solving it. For example:

```bash
python3 ./segmentation.py -s 100
```

There are also some parameters you can use to play with different-sized address spaces and physical memories. For example, to experiment with segmentation in a tiny system, you might type:

```bash
prompt> python3 ./segmentation.py -s 100 -a 16 -p 32

ARG seed 100
ARG address space size 16
ARG phys mem size 32

Segment register information:

  Segment 0 base  (grows positive) : 0x00000018 (decimal 24)
  Segment 0 limit                  : 4

  Segment 1 base  (grows negative) : 0x00000012 (decimal 18)
  Segment 1 limit                  : 5

Virtual Address Trace
  VA  0: 0x0000000c (decimal:   12) --> PA or segmentation violation?
  VA  1: 0x00000008 (decimal:    8) --> PA or segmentation violation?
  VA  2: 0x00000001 (decimal:    1) --> PA or segmentation violation?
  VA  3: 0x00000007 (decimal:    7) --> PA or segmentation violation?
  VA  4: 0x00000000 (decimal:    0) --> PA or segmentation violation?
```

which tells the program to generate virtual addresses for a 16-byte address space placed somewhere in a 32-byte physical memory. As you can see, the resulting virtual addresses are tiny (12, 8, 1, 7, and 0). Run with `-c` to see the answers.

Note you can specify bigger values by tacking a "k", "m", or even "g" onto the values you pass in with the `-a` or `-p` flags, as in "kilobytes", "megabytes", and "gigabytes". Thus, if you wanted to do some translations with a 1-MB address space set in a 32-MB physical memory, you might type:

```bash
python3 ./segmentation.py -a 1m -p 32m
```

If you want to get even more specific, you can set the base register and limit register values yourself, with the `--b0`, `--l0`, `--b1`, and `--l1` registers. Try them and see.

Finally, you can always run

```bash
python3 ./segmentation.py -h
```

to get a complete list of flags and options.

Enjoy!
